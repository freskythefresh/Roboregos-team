// Import the necessary libraries for controlling the sensors and motors:
#include <encoder.h>
#include <Ultrasonic.h>
#include <Adafruit_TCS34725.h>
#include <Wire.h>
#include <MPU6050.h>
<<<<<<< HEAD
=======
#include <I2Cdev.h>
#include <QTRSensors.h
>>>>>>> e9321a777561cfc3a5c6b1e3fbd1a293f0a3b58d

#define LINE_SENSOR_PIN A0  // Line sensor with 8 mini infrared sensors
#define QTR_Sensors 8
#define COLOR_SENSOR_1_SDA A4  // Color sensor 1 (Adafruit TCS34725) SDA
#define COLOR_SENSOR_1_SCL A5  // Color sensor 1 SCL
#define COLOR_SENSOR_2_SDA A6  // Color sensor 2 SDA
#define COLOR_SENSOR_2_SCL A7  // Color sensor 2 SCL
#define GYROSCOPE_SDA A8  // MPU6050 Gyroscope SDA
#define GYROSCOPE_SCL A9  // MPU6050 Gyroscope SCL

// Integrated Motor Encoder Pins
#define MOTOR_ENCODER_1_PIN_A 3
#define MOTOR_ENCODER_1_PIN_B 4
#define MOTOR_ENCODER_2_PIN_A 5
#define MOTOR_ENCODER_2_PIN_B 6
#define MOTOR_ENCODER_3_PIN_A 7
#define MOTOR_ENCODER_3_PIN_B 8
#define MOTOR_ENCODER_4_PIN_A 9
#define MOTOR_ENCODER_4_PIN_B 10

// Rotary Motor Encoder Pins
#define ROTARY_ENCODER_1_PIN_A 11
#define ROTARY_ENCODER_1_PIN_B 12
#define ROTARY_ENCODER_2_PIN_A A1
#define ROTARY_ENCODER_2_PIN_B A2
#define ROTARY_ENCODER_3_PIN_A A3
#define ROTARY_ENCODER_3_PIN_B A4
#define ROTARY_ENCODER_4_PIN_A A5
#define ROTARY_ENCODER_4_PIN_B A6

// 360 Vision Ultrasonics
#define ULTRASONIC_1_TRIG_PIN 2
#define ULTRASONIC_1_ECHO_PIN 3
#define ULTRASONIC_2_TRIG_PIN 4
#define ULTRASONIC_2_ECHO_PIN 5
#define ULTRASONIC_3_TRIG_PIN 6
#define ULTRASONIC_3_ECHO_PIN 7
#define ULTRASONIC_4_TRIG_PIN 8
#define ULTRASONIC_4_ECHO_PIN 9
#define ULTRASONIC_5_TRIG_PIN 10
#define ULTRASONIC_5_ECHO_PIN 11
#define ULTRASONIC_6_TRIG_PIN 12
#define ULTRASONIC_6_ECHO_PIN A0
#define ULTRASONIC_7_TRIG_PIN A1
#define ULTRASONIC_7_ECHO_PIN A2
#define ULTRASONIC_8_TRIG_PIN A3
#define ULTRASONIC_8_ECHO_PIN A4

// H bridge pins
#define H_BRIDGE_MOTOR_1_A 14
#define H_BRIDGE_MOTOR_1_B 15
#define H_BRIDGE_MOTOR_2_A 16
#define H_BRIDGE_MOTOR_2_B 17
#define H_BRIDGE_MOTOR_3_A 18
#define H_BRIDGE_MOTOR_3_B 19
#define H_BRIDGE_MOTOR_4_A 20
#define H_BRIDGE_MOTOR_4_B 21

// Ball detector ultrasonic
#define ULTRASONIC_UNDER_TRIG_PIN A7
#define ULTRASONIC_UNDER_ECHO_PIN A8

// Initializations
// Encoders
Encoder motorEncoder1(MOTOR_ENCODER_1_PIN_A, MOTOR_ENCODER_1_PIN_B);
Encoder motorEncoder2(MOTOR_ENCODER_2_PIN_A, MOTOR_ENCODER_2_PIN_B);
Encoder motorEncoder3(MOTOR_ENCODER_3_PIN_A, MOTOR_ENCODER_3_PIN_B);
Encoder motorEncoder4(MOTOR_ENCODER_4_PIN_A, MOTOR_ENCODER_4_PIN_B);

// Ultrasonics
Ultrasonic ultrasonicSensors[8] = {
    Ultrasonic(ULTRASONIC_1_TRIG_PIN, ULTRASONIC_1_ECHO_PIN),
    Ultrasonic(ULTRASONIC_2_TRIG_PIN, ULTRASONIC_2_ECHO_PIN),
    Ultrasonic(ULTRASONIC_3_TRIG_PIN, ULTRASONIC_3_ECHO_PIN),
    Ultrasonic(ULTRASONIC_4_TRIG_PIN, ULTRASONIC_4_ECHO_PIN),
    Ultrasonic(ULTRASONIC_5_TRIG_PIN, ULTRASONIC_5_ECHO_PIN),
    Ultrasonic(ULTRASONIC_6_TRIG_PIN, ULTRASONIC_6_ECHO_PIN),
    Ultrasonic(ULTRASONIC_7_TRIG_PIN, ULTRASONIC_7_ECHO_PIN),
    Ultrasonic(ULTRASONIC_8_TRIG_PIN, ULTRASONIC_8_ECHO_PIN),
    Ultrasonic(ULTRASONIC_UNDER_TRIG_PIN, ULTRASONIC_UNDER_ECHO_PIN),
  
};

Adafruit_TCS34725 colorSensor1;
Adafruit_TCS34725 colorSensor2;

<<<<<<< HEAD
=======

int i;

//Line sensor
QTRSensorsAnalog qtrrc((unsigned char[]) {A0, A1, A2, A3, A4, A5, A6, A7}, QTR_Sensors, TIMEOUT, LINE_SENSOR_PIN);

unsigned int sensorValues[QTR_Sensors]; 

int minSensorValue;
int maxSensorValue;

>>>>>>> e9321a777561cfc3a5c6b1e3fbd1a293f0a3b58d
//gyroscope
MPU6050 mpu;

float Map_Width = 0;
float Map_Height = 0;

int Mapgrid[Map_Width][Map_Height];

<<<<<<< HEAD
=======
const int usDelay = 3150; // Delay in ms to hold the sampling at 200Hz
const int NFast = 1000; // Number of quick readings for averaging, the higher the better
const int NSlow = 10000; // Number of slow readings for averaging, the higher the better
const int LinesBetweenHeaders = 5;

const int iAx = 0;
const int iAy = 1;
const int iAz = 2;
const int iGx = 3;
const int iGy = 4;
const int iGz = 5;

int LowValue[6];
int HighValue[6];
int Smoothed[6];
int LowOffset[6];
int HighOffset[6];
int Target[6] = {0,0,0,0,0,0};
int LinesOut = 0;
int N; //Average readings

>>>>>>> e9321a777561cfc3a5c6b1e3fbd1a293f0a3b58d
// Function declarations
void SetupMotores();
void SetupColorSensors();
void SetupUltrasonics();
void SetupLineSensor();
void SetupGyroscope();
void SetupWheelPosition();
void SetupMap();

// Main Functions
void Motores();
void ColorSensors();
void MainUltrasonics();
void BallUltrasonic();
void LineSensor();
void Gyroscope();
void WheelPosition();
void MapUpdate();


void setup() {
    Serial.begin(9600);

    // Initialize I2C communication for color sensors and gyroscope
    Wire.begin();

    // Initialize color sensors
    colorSensor1.begin(COLOR_SENSOR_1_SDA, COLOR_SENSOR_1_SCL);
    colorSensor2.begin(COLOR_SENSOR_2_SDA, COLOR_SENSOR_2_SCL);

    // Initialize gyroscope
    mpu.initialize(GYROSCOPE_SDA, GYROSCOPE_SCL);

    SetupMotores();
    SetupColorSensors();
    SetupUltrasonics();
    SetupLineSensor();
    SetupGyroscope();
    SetupWheelPosition();
    SetupMap();

    Serial.print("Setup Complete");
}

void loop() {
    Motores();
    ColorSensors();
    MainUltrasonics();
    BallUltrasonic();
    LineSensor();
    Gyroscope();
    WheelPosition();
    MapUpdate();

}

// Function to set up motors
void SetupMotores() {
    pinMode(H_BRIDGE_MOTOR_1_A, OUTPUT);
    pinMode(H_BRIDGE_MOTOR_1_B, OUTPUT);
    pinMode(H_BRIDGE_MOTOR_2_A, OUTPUT);
    pinMode(H_BRIDGE_MOTOR_2_B, OUTPUT);
    pinMode(H_BRIDGE_MOTOR_3_A, OUTPUT);
    pinMode(H_BRIDGE_MOTOR_3_B, OUTPUT);
    pinMode(H_BRIDGE_MOTOR_4_A, OUTPUT);
    pinMode(H_BRIDGE_MOTOR_4_B, OUTPUT);
}

// Function to set up color sensors
void SetupColorSensors() {
    colorSensor1.begin(COLOR_SENSOR_1_SDA, COLOR_SENSOR_1_SCL);
    colorSensor2.begin(COLOR_SENSOR_2_SDA, COLOR_SENSOR_2_SCL);
}

// Function to set up ultrasonic sensors
void SetupUltrasonics() {
    for (int i = 0; i < 8; i++) {
        pinMode(ultrasonicSensors[i].trigPin, OUTPUT);
        pinMode(ultrasonicSensors[i].echoPin, INPUT);
    }
}

// Function to set up line sensor
void SetupLineSensor() {
    pinMode(LINE_SENSOR_PIN, INPUT);
}

// Function to set up gyroscope
void SetupGyroscope() {
    mpu.initialize();
}

void SetupWheelPosition() {
    //Manualrotation

    //Read one full looop and check if reading correctly manualy

    //print each wheel individually

<<<<<<< HEAD
    //Make Origin
    motorEncoder1.write(0);
    motorEncoder2.write(0);
    motorEncoder3.write(0);
    motorEncoder4.write(0);
=======
/* Function to configure the obtained offsets */
    void SetOffsets(int TheOffsets[6]) {
    mpu.setXAccelOffset(TheOffsets[iAx]);
    mpu.setYAccelOffset(TheOffsets[iAy]);
    mpu.setZAccelOffset(TheOffsets[iAz]);
    mpu.setXGyroOffset(TheOffsets[iGx]);
    mpu.setYGyroOffset(TheOffsets[iGy]);
    mpu.setZGyroOffset(TheOffsets[iGz]);
}
>>>>>>> e9321a777561cfc3a5c6b1e3fbd1a293f0a3b58d

<<<<<<< HEAD
    mpu.setAngle(0);
=======
void SetupLineSensor() {
    // Begin calibration process
    Serial.println("Calibrating line sensor");
    
    // Capture minimum and maximum values for each sensor
    for (int i = 0; i < QTR_Sensors; i++) {
        minSensorValue = 1023;  // Reset min value
        maxSensorValue = 0;     // Reset max value
    }

    for (int i = 0; i < 1000; i++) {  
        qtrrcSensor.read(sensorValues);
    for (int j = 0; j < QTR_Sensors; j++) {
            if (sensorValues[j] < minSensorValue)
                minSensorValue = sensorValues[j];
            if (sensorValues[j] > maxSensorValue)
                maxSensorValue = sensorValues[j];
        }
        delay(10);
    }

    Serial.println("Calibration complete");
    Serial.print("Min Value: ");
    Serial.println(minSensorValue);
    Serial.print("Max Value: ");
    Serial.println(maxSensorValue);
}



void SetupWheelPosition() {
>>>>>>> e9321a777561cfc3a5c6b1e3fbd1a293f0a3b58d

    Serial.println("Wheel Position and Gyroscope aligned")

}

// Function to set up map (add your logic here)
void SetupMap() {
        Serial.println("Mapping matrix initialized.");
}

//Main functions
void Motores() {
}

void ColorSensors() {
    // Add logic to read color sensors and process their output
}

void MainUltrasonics() {
    // Add logic for main ultrasonic sensor processing
}

void BallUltrasonic() {
    // Logic for detecting ball with ultrasonic sensor
}

// QTR 8A Line sensor

void LineSensor() {
<<<<<<< HEAD
    // Logic for following line using line sensors
=======
    // Get sensor readings
    qtrSensor.read(sensorValues);

    // Use calibrated min/max values to normalize sensor readings
    unsigned int normalizedValues[QTR_SENSOR_COUNT];
    for (int i = 0; i < QTR_SENSOR_COUNT; i++) {
        normalizedValues[i] = map(sensorValues[i], minSensorValues[i], maxSensorValues[i], 0, 1000);
    }

    // Calculate position on the line using normalized sensor readings
    unsigned int position = qtrSensor.readLine(normalizedValues);

    // Display sensor values and calculated position
    Serial.print("Sensor Values: ");
    for (int i = 0; i < QTR_SENSOR_COUNT; i++) {
        Serial.print(sensorValues[i]);
        Serial.print("\t");
    }
    Serial.print("Position: ");
    Serial.println(position);
>>>>>>> e9321a777561cfc3a5c6b1e3fbd1a293f0a3b58d
}

mpu.getMotion6(&ax, &ay, &az, &gx, &gy, &gz);

// Apply calibration offsets
ax -= xAccelOffset;
ay -= yAccelOffset;
az -= zAccelOffset;
gx -= xGyroOffset;
gy -= yGyroOffset;
gz -= zGyroOffset;

// Calculate angles from accelerometer
float accelAngleX = atan2(ay, az) * RAD_TO_DEG;
float accelAngleY = atan2(ax, az) * RAD_TO_DEG;

// Complementary filter to combine gyro and accelerometer data
angleX = alpha * (angleX + gx * dt) + (1 - alpha) * accelAngleX;
angleY = alpha * (angleY + gy * dt) + (1 - alpha) * accelAngleY;

// Calculate magnitude of acceleration
float accelMagnitude = sqrt(ax * ax + ay * ay + az * az);

// Calculate the angle in the X-Y plane
float accelAngleXY = atan2(ay, ax) * RAD_TO_DEG;

// Output angles
Serial.print("\tAccel Magnitude: ");
Serial.print(accelMagnitude);
Serial.print("\tAccel Angle XY: ");
Serial.println(accelAngleXY);

delay(dt);


void WheelPosition() {
    // Logic for tracking wheel position
}

void MapUpdate() {
    // Logic for updating the robot's map or position
}

// - Motores: controlar los motores con encoders de Arduino para asegurar precisión.
// - Sensores ultrasónicos: medir la distancia para evitar colisiones en la pista C y rampa.
// - Sensor de color: para detección de colores específicos en Pistas A y C.
// - Sensores infrarrojos: seguir la línea negra en Pista B.
// - Giroscopio de 3 ejes: para estabilización en el sube y baja.
// - Encoders rotativos: redundancia en el control de movimiento.

// Definir variables globales y parámetros clave:
// - Tamaño de la pista: las unidades son de **30 x 30 cm**.
// - Pista A: 3 x 3 unidades (90 x 90 cm).
// - Pista B: 5 x 4 unidades (150 x 120 cm).
// - Pista C: 5 x 3 unidades (150 x 90 cm).
// - Sube y baja: 3 unidades de largo (90 cm), inclinación máxima de 22° ± 2°.
// - Tamaño de la pelota azul en Pista A: **diámetro de 7.5 cm**.

// Colores a detectar:
// - **Pista A:** Pelota azul.
// - **Pista B:** Línea negra sobre fondo blanco.
// - **Pista C:** Amarillo, morado, rosa (correctos), negro (dead end a evitar).
// - Checkpoints: verde (inicio), rojo (final).
