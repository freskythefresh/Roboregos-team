// Import the necessary libraries for controlling the sensors and motors:
#include <encoder.h>
#include <Ultrasonic.h>
#include <Adafruit_TCS34725.h>
#include <Wire.h>
#include <MPU6050.h>
#include <I2Cdev.h>
#include <QTRSensors.h

#define LINE_SENSOR_PIN A0  // Line sensor with 8 mini infrared sensors
#define QTR_Sensors 8
#define COLOR_SENSOR_1_SDA A4  // Color sensor 1 (Adafruit TCS34725) SDA
#define COLOR_SENSOR_1_SCL A5  // Color sensor 1 SCL
#define COLOR_SENSOR_2_SDA A6  // Color sensor 2 SDA
#define COLOR_SENSOR_2_SCL A7  // Color sensor 2 SCL
#define GYROSCOPE_SDA A8
#define GYROSCOPE_SCL A9
#define OUTPUT_READABLE_ACCELGYRO

// Integrated Motor Encoder Pins
#define MOTOR_ENCODER_1_PIN_A 3
#define MOTOR_ENCODER_1_PIN_B 4
#define MOTOR_ENCODER_2_PIN_A 5
#define MOTOR_ENCODER_2_PIN_B 6
#define MOTOR_ENCODER_3_PIN_A 7
#define MOTOR_ENCODER_3_PIN_B 8
#define MOTOR_ENCODER_4_PIN_A 9
#define MOTOR_ENCODER_4_PIN_B 10

// Rotary Motor Encoder Pins
#define ROTARY_ENCODER_1_PIN_A 11
#define ROTARY_ENCODER_1_PIN_B 12
#define ROTARY_ENCODER_2_PIN_A A1
#define ROTARY_ENCODER_2_PIN_B A2
#define ROTARY_ENCODER_3_PIN_A A3
#define ROTARY_ENCODER_3_PIN_B A4
#define ROTARY_ENCODER_4_PIN_A A5
#define ROTARY_ENCODER_4_PIN_B A6

// 360 Vision Ultrasonics
#define ULTRASONIC_1_TRIG_PIN 2
#define ULTRASONIC_1_ECHO_PIN 3
#define ULTRASONIC_2_TRIG_PIN 4
#define ULTRASONIC_2_ECHO_PIN 5
#define ULTRASONIC_3_TRIG_PIN 6
#define ULTRASONIC_3_ECHO_PIN 7
#define ULTRASONIC_4_TRIG_PIN 8
#define ULTRASONIC_4_ECHO_PIN 9
#define ULTRASONIC_5_TRIG_PIN 10
#define ULTRASONIC_5_ECHO_PIN 11
#define ULTRASONIC_6_TRIG_PIN 12
#define ULTRASONIC_6_ECHO_PIN A0
#define ULTRASONIC_7_TRIG_PIN A1
#define ULTRASONIC_7_ECHO_PIN A2
#define ULTRASONIC_8_TRIG_PIN A3
#define ULTRASONIC_8_ECHO_PIN A4

// H bridge pins
#define H_BRIDGE_MOTOR_1_A 14
#define H_BRIDGE_MOTOR_1_B 15
#define H_BRIDGE_MOTOR_2_A 16
#define H_BRIDGE_MOTOR_2_B 17
#define H_BRIDGE_MOTOR_3_A 18
#define H_BRIDGE_MOTOR_3_B 19
#define H_BRIDGE_MOTOR_4_A 20
#define H_BRIDGE_MOTOR_4_B 21

// Ball detector ultrasonic
#define ULTRASONIC_UNDER_TRIG_PIN A7
#define ULTRASONIC_UNDER_ECHO_PIN A8

// Initializations
// Encoders
Encoder motorEncoder1(MOTOR_ENCODER_1_PIN_A, MOTOR_ENCODER_1_PIN_B);
Encoder motorEncoder2(MOTOR_ENCODER_2_PIN_A, MOTOR_ENCODER_2_PIN_B);
Encoder motorEncoder3(MOTOR_ENCODER_3_PIN_A, MOTOR_ENCODER_3_PIN_B);
Encoder motorEncoder4(MOTOR_ENCODER_4_PIN_A, MOTOR_ENCODER_4_PIN_B);

// Ultrasonics
Ultrasonic ultrasonicSensors[8] = {
    Ultrasonic(ULTRASONIC_1_TRIG_PIN, ULTRASONIC_1_ECHO_PIN),
    Ultrasonic(ULTRASONIC_2_TRIG_PIN, ULTRASONIC_2_ECHO_PIN),
    Ultrasonic(ULTRASONIC_3_TRIG_PIN, ULTRASONIC_3_ECHO_PIN),
    Ultrasonic(ULTRASONIC_4_TRIG_PIN, ULTRASONIC_4_ECHO_PIN),
    Ultrasonic(ULTRASONIC_5_TRIG_PIN, ULTRASONIC_5_ECHO_PIN),
    Ultrasonic(ULTRASONIC_6_TRIG_PIN, ULTRASONIC_6_ECHO_PIN),
    Ultrasonic(ULTRASONIC_7_TRIG_PIN, ULTRASONIC_7_ECHO_PIN),
    Ultrasonic(ULTRASONIC_8_TRIG_PIN, ULTRASONIC_8_ECHO_PIN),
    Ultrasonic(ULTRASONIC_UNDER_TRIG_PIN, ULTRASONIC_UNDER_ECHO_PIN),
  
};

Adafruit_TCS34725 colorSensor1;
Adafruit_TCS34725 colorSensor2;


int i;

//Line sensor
QTRSensorsAnalog qtrrc((unsigned char[]) {A0, A1, A2, A3, A4, A5, A6, A7}, QTR_Sensors, TIMEOUT, LINE_SENSOR_PIN);

unsigned int sensorValues[QTR_Sensors]; 

int minSensorValue;
int maxSensorValue;

//gyroscope
MPU6050 mpu;

float angleX = 0.0;
float angleY = 0.0;
float angleZ = 0.0; 

float ax, ay, az, gx, gy, gz;
float xAccelOffset, yAccelOffset, zAccelOffset;
float xGyroOffset, yGyroOffset, zGyroOffset;
float alpha = 0.98;
float dt = 0.01;

const int usDelay = 3150; // Delay in ms to hold the sampling at 200Hz
const int NFast = 1000; // Number of quick readings for averaging, the higher the better
const int NSlow = 10000; // Number of slow readings for averaging, the higher the better
const int LinesBetweenHeaders = 5;

const int iAx = 0;
const int iAy = 1;
const int iAz = 2;
const int iGx = 3;
const int iGy = 4;
const int iGz = 5;

int LowValue[6];
int HighValue[6];
int Smoothed[6];
int LowOffset[6];
int HighOffset[6];
int Target[6] = {0,0,0,0,0,0};
int LinesOut = 0;
int N; //Average readings

// Function declarations
void SetupMotores();
void SetupColorSensors();
void SetupUltrasonics();
void SetupLineSensor();
void SetupGyroscope();
void SetupWheelPosition();
void SetupMap();

// Main Functions
void Motores();
void ColorSensors();
void MainUltrasonics();
void BallUltrasonic();
void LineSensor();
void Gyroscope();
void WheelPosition();
void MapUpdate();


void setup() {
    Serial.begin(1000);

    // Initialize I2C communication for color sensors and gyroscope
    Wire.begin();

    // Initialize color sensors
    colorSensor1.begin(COLOR_SENSOR_1_SDA, COLOR_SENSOR_1_SCL);
    colorSensor2.begin(COLOR_SENSOR_2_SDA, COLOR_SENSOR_2_SCL);

    // Initialize gyroscope
    mpu.initialize();

    SetupGyroscope();
    
    SetupMotores();
    SetupColorSensors();
    SetupUltrasonics();
    SetupLineSensor();
}
 // Gyroscope Calibration
void SetupGyroscope() {
    /*--Start I2C interface--*/
    #if I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE
        Wire.begin(); 
    #elif I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_FASTWIRE
        Fastwire::setup(400, true);
    #endif

    /* Initialize device and check connection */ 
    Serial.println("Initializing MPU...");
    mpu.initialize();
    
    if (!mpu.testConnection()) {
        Serial.println("MPU6050 connection failed");
        while (true);  // Infinite loop if connection fails
    } else {
        Serial.println("MPU6050 connection successful");
    }

    Serial.println("\nXAccel\t\tYAccel\t\tZAccel\t\tXGyro\t\tYGyro\t\tZGyro");
    
    // Calibrate and print offsets in a loop
    for (int i = 6; i <= 10; i++) {
        mpu.CalibrateAccel(i);
        mpu.CalibrateGyro(i);
        Serial.print(i * 100); // Total readings
        Serial.println(" Total Readings");
        mpu.PrintActiveOffsets();
    }
    Serial.println("\nAny of the above offsets will work nicely \n\nProving the PID with other method:");
}

void SetAveraging(int NewN) {
    N = NewN;
    Serial.print("\nAveraging ");
    Serial.print(N);
    Serial.println(" readings each time");
}

void PullBracketsOut() {
    Serial.println("Expanding:");
    ForceHeader();
    bool Done = false;

    while (!Done) {
        Done = true;
        SetOffsets(LowOffset);
        GetSmoothed();

        for (int i = 0; i <= 5; i++) {
            LowValue[i] = Smoothed[i];
            if (LowValue[i] >= Target[i]) {
                Done = false;
                LowOffset[i] -= 1000;
            }
        }

        SetOffsets(HighOffset);
        GetSmoothed();

        for (int i = 0; i <= 5; i++) {
            HighValue[i] = Smoothed[i];
            if (HighValue[i] <= Target[i]) {
                Done = false;
                HighOffset[i] += 1000;
            }
        }
    }
}

void PullBracketsIn() {
    Serial.println("\nClosing in:");
    ForceHeader();
    bool AllBracketsNarrow = false;
    bool StillWorking = true;

    while (StillWorking) {
        StillWorking = false;
        if (AllBracketsNarrow && (N == NFast)) {
            SetAveraging(NSlow);
        } else {
            AllBracketsNarrow = true;
        }

        int NewOffset[6];
        for (int i = 0; i <= 5; i++) {
            if (HighOffset[i] <= (LowOffset[i] + 1)) {
                NewOffset[i] = LowOffset[i];
            } else {
                StillWorking = true;
                NewOffset[i] = (LowOffset[i] + HighOffset[i]) / 2;
                if (HighOffset[i] > (LowOffset[i] + 10)) {
                    AllBracketsNarrow = false;
                }
            }
        }
        SetOffsets(NewOffset);
        GetSmoothed();

        for (int i = 0; i <= 5; i++) { // Closing in
            if (Smoothed[i] > Target[i]) {
                HighOffset[i] = NewOffset[i];
            } else {
                LowOffset[i] = NewOffset[i];
            }
        }
    }
}

/* Function to smooth the read values */
void GetSmoothed() {
    int16_t RawValue[6];
    long Sums[6] = {0};

    for (int i = 1; i <= N; i++) { 
        mpu.getMotion6(&RawValue[iAx], &RawValue[iAy], &RawValue[iAz], &RawValue[iGx], &RawValue[iGy], &RawValue[iGz]);
        delayMicroseconds(usDelay);
        for (int j = 0; j <= 5; j++) {
            Sums[j] += RawValue[j];
        }
    }

    for (int i = 0; i <= 5; i++) {
        Smoothed[i] = (Sums[i] + N / 2) / N;  // Round to nearest integer
    }
}

/* Function to configure the obtained offsets */
    void SetOffsets(int TheOffsets[6]) {
    mpu.setXAccelOffset(TheOffsets[iAx]);
    mpu.setYAccelOffset(TheOffsets[iAy]);
    mpu.setZAccelOffset(TheOffsets[iAz]);
    mpu.setXGyroOffset(TheOffsets[iGx]);
    mpu.setYGyroOffset(TheOffsets[iGy]);
    mpu.setZGyroOffset(TheOffsets[iGz]);
}

void SetupLineSensor() {
    // Begin calibration process
    Serial.println("Calibrating line sensor");
    
    // Capture minimum and maximum values for each sensor
    for (int i = 0; i < QTR_Sensors; i++) {
        minSensorValue = 1023;  // Reset min value
        maxSensorValue = 0;     // Reset max value
    }

    for (int i = 0; i < 1000; i++) {  
        qtrrcSensor.read(sensorValues);
    for (int j = 0; j < QTR_Sensors; j++) {
            if (sensorValues[j] < minSensorValue)
                minSensorValue = sensorValues[j];
            if (sensorValues[j] > maxSensorValue)
                maxSensorValue = sensorValues[j];
        }
        delay(10);
    }

    Serial.println("Calibration complete");
    Serial.print("Min Value: ");
    Serial.println(minSensorValue);
    Serial.print("Max Value: ");
    Serial.println(maxSensorValue);
}



void SetupWheelPosition() {

}
  

void SetupMap() {

}

//Main Functions
void Motores() {

}

void ColorSensors() {

}

void MainUltrasonics() {
 
}

void BallUltrasonic() {
    
}

// QTR 8A Line sensor

void LineSensor() {
    // Get sensor readings
    qtrSensor.read(sensorValues);

    // Use calibrated min/max values to normalize sensor readings
    unsigned int normalizedValues[QTR_SENSOR_COUNT];
    for (int i = 0; i < QTR_SENSOR_COUNT; i++) {
        normalizedValues[i] = map(sensorValues[i], minSensorValues[i], maxSensorValues[i], 0, 1000);
    }

    // Calculate position on the line using normalized sensor readings
    unsigned int position = qtrSensor.readLine(normalizedValues);

    // Display sensor values and calculated position
    Serial.print("Sensor Values: ");
    for (int i = 0; i < QTR_SENSOR_COUNT; i++) {
        Serial.print(sensorValues[i]);
        Serial.print("\t");
    }
    Serial.print("Position: ");
    Serial.println(position);
}

void Gyroscope() {

mpu.getMotion6(&ax, &ay, &az, &gx, &gy, &gz);

// Apply calibration offsets
ax -= xAccelOffset;
ay -= yAccelOffset;
az -= zAccelOffset;
gx -= xGyroOffset;
gy -= yGyroOffset;
gz -= zGyroOffset;

// Calculate angles from accelerometer
float accelAngleX = atan2(ay, az) * RAD_TO_DEG;
float accelAngleY = atan2(ax, az) * RAD_TO_DEG;

// Complementary filter to combine gyro and accelerometer data
angleX = alpha * (angleX + gx * dt) + (1 - alpha) * accelAngleX;
angleY = alpha * (angleY + gy * dt) + (1 - alpha) * accelAngleY;
angleZ = alpha * (angleZ + gz * dt);  
// Calculate magnitude of acceleration
float accelMagnitude = sqrt(ax * ax + ay * ay);

// Calculate the angle in the X-Y plane
float accelAngleXY = atan2(ay, ax) * RAD_TO_DEG;

// Output angles
Serial.print("Angle X: ");
Serial.print(angleX);
Serial.print("\tAngle Y: ");
Serial.print(angleY);
Serial.print("Angle Z: ");
Serial.print(angleZ);
Serial.print("\tAccel Magnitude: ");
Serial.print(accelMagnitude);
Serial.print("\tAccel Angle XY: ");
Serial.println(accelAngleXY);

delay(dt);

}

void WheelPosition() {
   
}

void MapUpdate() {
  
}

// - Motores: controlar los motores con encoders de Arduino para asegurar precisión.
// - Sensores ultrasónicos: medir la distancia para evitar colisiones en la pista C y rampa.
// - Sensor de color: para detección de colores específicos en Pistas A y C.
// - Sensores infrarrojos: seguir la línea negra en Pista B.
// - Giroscopio de 3 ejes: para estabilización en el sube y baja.
// - Encoders rotativos: redundancia en el control de movimiento.

// Definir variables globales y parámetros clave:
// - Tamaño de la pista: las unidades son de **30 x 30 cm**.
// - Pista A: 3 x 3 unidades (90 x 90 cm).
// - Pista B: 5 x 4 unidades (150 x 120 cm).
// - Pista C: 5 x 3 unidades (150 x 90 cm).
// - Sube y baja: 3 unidades de largo (90 cm), inclinación máxima de 22° ± 2°.
// - Tamaño de la pelota azul en Pista A: **diámetro de 7.5 cm**.

// Colores a detectar:
// - **Pista A:** Pelota azul.
// - **Pista B:** Línea negra sobre fondo blanco.
// - **Pista C:** Amarillo, morado, rosa (correctos), negro (dead end a evitar).
// - Checkpoints: verde (inicio), rojo (final).
